{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib","mergelive.min.js","lib/diffsync/handler.js","lib/diffsync/server.js","lib/diffsync/syncdoc.js","node_modules/jiff/jiff.js","node_modules/jiff/lib/InvalidPatchOperationError.js","node_modules/jiff/lib/PatchNotInvertibleError.js","node_modules/jiff/lib/TestFailedError.js","node_modules/jiff/lib/array.js","node_modules/jiff/lib/clone.js","node_modules/jiff/lib/commutePaths.js","node_modules/jiff/lib/deepEquals.js","node_modules/jiff/lib/inverse.js","node_modules/jiff/lib/jsonPatch.js","node_modules/jiff/lib/jsonPointer.js","node_modules/jiff/lib/jsonPointerParse.js","node_modules/jiff/lib/lcs.js","node_modules/jiff/lib/patches.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","mergelive","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"SyncDocument","SyncServer","SyncHandler","./diffsync/handler","./diffsync/server","./diffsync/syncdoc",2,"options","socket","get_object","oninit","error","onchange","handler","onerror","console","document","onmessage","bind","prototype","require_document","load","query","callback","send","JSON","stringify","type","data","push","edits","message","message_object","parse","handle_init","object","handle_acknowledge","version","acknowledge","handle_pull","forEach","edit","pull","handle_load","handle_error","./syncdoc",3,"last_connection_id","handlers","on","onconnection","id","broadcast_change","sender_id","Object","keys","handler_id","./handler",4,"jiff","diff","patch","copy","obj","shadow","other_version","backup","delta","rollback","filter","receipt",5,"b","appendChanges","initState","hash","orElse","isFunction","defaultHash","makeContext","defaultContext","path","state","Array","isArray","appendArrayChanges","isValidObject","appendObjectChanges","appendValueChanges","o1","o2","key","keyPath","encodeSegment","op","value","p","a1","a2","a1hash","array","map","a2hash","lcsMatrix","lcs","compare","lcsToJsonPatch","offset","reduce","j","last","context","REMOVE","ADD","predicate","x","y","inverse","jsonPointer","apply","patchInPlace","applyInPlace","clone","InvalidPatchOperationError","TestFailedError","PatchNotInvertibleError","./lib/InvalidPatchOperationError","./lib/PatchNotInvertibleError","./lib/TestFailedError","./lib/array","./lib/inverse","./lib/jsonPatch","./lib/jsonPointer","./lib/lcs",6,"name","constructor","captureStackTrace","create",7,8,9,"cons","tail",10,"cloneArray","cloneObject","k",11,"commuteTreePaths","left","right","TypeError","commuteArrayPaths","commuteArraySiblings","commuteArrayAncestor","absolute","join","isArrayPath","index","isValidArrayIndex","lpath","rpath","commuted","target","lindex","rindex","slice","Math","max","direction","rc","getCommonPathPrefix","p1","p2","p1l","p2l","min","copyPatch","from","prefix","ac","bc","./jsonPointer",12,"deepEquals","compareArrays","compareObjects","akeys","bkeys",13,"invertOp","c","patches","skip","pr","./patches",14,"changes","defaultOptions","./InvalidPatchOperationError","./clone",15,"find","findContext","separator","parent","hasContext","_parse","segment","findIndex","parseArrayIndex","segments","contains","indexOf","decodeSegment","replace","encodedSeparatorRx","encodedEscapeRx","escapeChar","escapeRx","encodedEscape","separatorRx","encodedSeparator","arrayIndexRx","test","SyntaxError","start","./jsonPointerParse",16,"jsonPointerParse","onSegment","pos","accum","matches","match","charAt","parseRx","lastIndex","exec",17,"cols","rows","findPrefix","suffix","findSuffix","remove","matrix","createMatrix","backtrack","m","SKIP","RIGHT","DOWN","al","bl","lastrow","EQUAL",18,"applyTest","pointer","invertTest","commuteTest","commutePaths","applyAdd","change","notFound","val","_add","splice","invertAdd","add","before","after","commuteAddOrCopy","applyReplace","missingValue","invertReplace","prev","commuteReplace","applyRemove","_remove","removed","invertRemove","commuteRemove","applyMove","pto","pfrom","fromContext","invertMove","commuteMove","move","applyCopy","notInvertible","_","commute","./PatchNotInvertibleError","./TestFailedError","./array","./commutePaths","./deepEquals"],"mappings":"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","file":"mergelive.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = \n{\n\tSyncDocument: require('./diffsync/syncdoc').SyncDocument,\n    SyncServer: require('./diffsync/server').SyncServer,\n    SyncHandler: require('./diffsync/handler').SyncHandler\n}",null,"var SyncDocument = require('./syncdoc').SyncDocument\n\n\nvar SyncHandler = function (options)\n{\n    options = options || {}\n    \n    if (!options.socket)\n    {\n        throw new Error(\"You must provide a web socket.\")\n    }\n    \n    this.socket = options.socket\n    this.get_object = options.get_object\n    this.oninit = options.oninit || function (error) {}\n    this.onchange = options.onchange || function (handler) {}\n    this.onerror = options.onerror || function (error) { console.error(error) }\n    this.document = null\n    \n    this.socket.onmessage = this.onmessage.bind(this)\n}\n\nSyncHandler.prototype.require_document = function ()\n{\n    if (!this.document)\n    {\n        throw new Error(\"No document, you must load one first.\")\n    }\n}\n\nSyncHandler.prototype.load = function (query, callback)\n{\n    this.socket.send(JSON.stringify({type:'load', data:query}), callback)\n}\n\nSyncHandler.prototype.push = function (callback)\n{\n    this.require_document()\n    this.document.push()\n    \n    if (this.document.edits.length > 0)\n    {\n        this.socket.send(JSON.stringify({type:'pull', data: this.document.edits}), callback)\n    }\n    else if (callback)\n    {\n        callback()\n    }\n}\n\nSyncHandler.prototype.onmessage = function (message)\n{\n    var message_object = JSON.parse(message)\n    if (!message_object.type)\n    {\n        throw new Error(\"Message is missing a type\")\n    }\n    \n    var handler = \"handle_\" + message_object.type\n    if (!this[handler])\n    {\n        throw new Error(\"Unknown message type: \" + message_object.type)\n    }\n    \n    this[handler](message_object.data)\n}\n\nSyncHandler.prototype.handle_init = function (object)\n{\n    this.document = new SyncDocument(object)\n    this.oninit()\n}\n\nSyncHandler.prototype.handle_acknowledge = function (version)\n{\n    this.require_document()\n    this.document.acknowledge(version)\n}\n\nSyncHandler.prototype.handle_pull = function (edits)\n{\n    this.require_document()\n    edits.forEach(function (edit)\n    {\n        this.document.pull(edit)\n    }.bind(this))\n    \n    this.onchange(this.document.object)\n}\n\nSyncHandler.prototype.handle_load = function (query)\n{\n    if (!this.get_object)\n    {\n        this.socket.send(JSON.stringify({type:'error', data: 'No object loader available.'}))\n        return\n    }\n    \n    var object = this.get_object(query)\n    \n    if (!object)\n    {\n        this.socket.send(JSON.stringify({type:'error', data: 'Object could not be loaded.'}))\n        return\n    }\n    \n    this.document = new SyncDocument(object)\n    this.socket.send(JSON.stringify({type: 'init', data: object}))\n}\n\nSyncHandler.prototype.handle_error = function (error)\n{\n    this.onerror(error)\n}\n\nmodule.exports = \n{\n    SyncHandler: SyncHandler\n}","var SyncHandler = require('./handler').SyncHandler\n\n\nvar SyncServer = function (options)\n{\n\toptions = options || {}\n\t\n\tif (!options.socket)\n\t{\n\t\tthrow new Error(\"A socket is required.\")\n\t}\n\t\n\tif (!options.get_object)\n\t{\n\t\tthrow new Error(\"A `get_object` function is required.\")\n\t}\n\t\n\tthis.get_object = options.get_object\n\tthis.socket = options.socket\n\tthis.onchange = options.onchange || function () {}\n\tthis.last_connection_id = 0\n\tthis.handlers = {}\n\t\n\tthis.socket.on('connection', this.onconnection.bind(this))\n}\n\nSyncServer.prototype.onconnection = function (socket)\n{\n\tvar id = this.last_connection_id,\n\t\thandler = new SyncHandler(\n\t\t{\n\t\t\tsocket: socket,\n\t\t\tget_object: this.get_object,\n\t\t\tonchange: function (object)\n\t\t\t{\n\t\t\t\tthis.onchange(object)\n\t\t\t\tthis.broadcast_change(id, object)\n\t\t\t}.bind(this)\n\t\t})\n\t\t\n\tthis.handlers[id] = handler\n\tsocket.on(\"close\", function ()\n\t{\n\t\tdelete this.handlers[id]\n\t}.bind(this))\n}\n\nSyncServer.prototype.broadcast_change = function (sender_id)\n{\n\tObject.keys(this.handlers, function (handler_id)\n\t{\n\t\tif (handler_id != sender_id)\n\t\t{\n\t\t\tvar handler = this.handlers[handler_id]\n\t\t\t\n\t\t\tif (handler)\n\t\t\t{\n\t\t\t\thandler.push()\n\t\t\t}\n\t\t}\n\t}.bind(this))\n}\n\n\nmodule.exports = \n{\n\tSyncServer: SyncServer\n}\n","var jiff = require('jiff'),\n\tdiff = jiff.diff,\n\tpatch = jiff.patch,\n\tcopy = function (obj) { return JSON.parse(JSON.stringify(obj)) }\n\n\nvar SyncDocument = function SyncDocument (object)\n{\n\t/* The canonical version of our object. Edit this. */\n\tthis.object = object\n\t\n\t/* A shadow that maintains sync with our buddy's shadow. */\n\tthis.shadow = {\n\t\tversion: 0,\n\t\tother_version: 0,\n\t\tobject: copy(object)\n\t}\n\t\n\t/* A backup of the shadow we can use to rollback if updates\n\tare dropped by our buddy */\n\tthis.backup = {\n\t\tversion: 0,\n\t\tobject: copy(object)\n\t}\n\t\n\t/* A stack of our edits that have not been confirmed by our buddy. */\n\tthis.edits = []\n}\n\n\nSyncDocument.prototype.push = function ()\n{\n\t/* First let's try to create a delta against our shadow */\n\tvar delta = diff(this.shadow.object, this.object)\n\t\n\t/* If there aren't any changes, we're done. */\n\tif (delta.length == 0)\n\t{\n\t\treturn\n\t}\n\t\n\t/* An edit is a delta along with some version information for housekeeping. */\n\tvar edit = {\n\t\tversion: this.shadow.version,\n\t\tother_version: this.shadow.other_version,\n\t\tdelta: delta\n\t}\n\t\n\t/* First back up our shadow */\n\tthis.backup.object = this.shadow.object\n\tthis.backup.version = this.shadow.version\n\t\n\t/*  Then copy the latest version to the shadow and increment the shadow's version */\n\tthis.shadow.object = copy(this.object)\n\tthis.shadow.version++\n\t\n\t/* Then send the edit to our buddy to be applied to its shadow. */\n\tthis.edits.push(edit)\n}\n\nSyncDocument.prototype.pull = function (edit)\n{\n\t/* The edit comes from our buddy. The edit's version is the base version\n\tof our buddy's diff (our \"other_version\"). */\n\t\n\t/* If there are no changes, we are dealing with an acknowledgement of the\n\tlast version received by our buddy */\n\tif (!edit.delta)\n\t{\n\t\tthis.acknowledge(edit.other_version)\n\t\treturn\n\t}\n\t\n\t/* If the edit version is older than the version we last got from our buddy it \n\tmeans we already saw this edit and most likely our acknowledgement was dropped.\n\tWe don't need to do anything about this. */\n\tif (edit.version < this.shadow.other_version)\n\t{\n\t\treturn\n\t}\n\t\n\t/*\n\tIf the last version of us our buddy got doesn't match our current version\n\tit means our buddy missed some of our edits. We need to rollback.\n\t*/\n\tif (edit.other_version != this.shadow.version)\n\t{\n\t\tthis.rollback()\n\t\treturn\n\t}\n\t\n\t/* If all the version numbers match up we can patch our shadow and then \n\tattempt to patch our canonical version */\n\tthis.shadow.object = patch(edit.delta, this.shadow.object)\n\tthis.shadow.other_version = edit.version + 1\n\t\n\t/* If our canonical version is just too different, we can skip this patch and send out the\n\tdelta between our canonical version and patched shadow effectively clobbering this edit\n\ton our buddy's end */\n\ttry\n\t{\n\t\tthis.object = patch(edit.delta, this.object)\n\t}\n\tcatch (e)\n\t{\n\t\tthis.push()\n\t}\n\t\n\tthis.acknowledge(edit.other_version)\n}\n\nSyncDocument.prototype.acknowledge = function (version)\n{\n\t/* Remove any edits in our edit stack that are against the last version our buddy \n\thas just confirmed so that they aren't resent */\n\tthis.edits = this.edits.filter(function (e)\n\t{\n\t\treturn version < e.version\n\t})\n}\n\nSyncDocument.prototype.rollback = function (edit)\n{\n\t/* Clear all outgoing edits since they are based on a version we are clobbering */\n\tthis.edits = []\n\t\n\t/* Restore the shadow from the backup */\n\tthis.shadow.object = copy(this.backup.object)\n\tthis.shadow.version = this.backup.version\n\t\n\t/* Apply the edit per usual */\n\tthis.pull(edit)\n}\n\nSyncDocument.prototype.receipt = function ()\n{\n\treturn this.shadow.other_version\n}\n\nmodule.exports = \n{\n\tSyncDocument: SyncDocument\n}","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar lcs = require('./lib/lcs');\nvar array = require('./lib/array');\nvar patch = require('./lib/jsonPatch');\nvar inverse = require('./lib/inverse');\nvar jsonPointer = require('./lib/jsonPointer');\nvar encodeSegment = jsonPointer.encodeSegment;\n\nexports.diff = diff;\nexports.patch = patch.apply;\nexports.patchInPlace = patch.applyInPlace;\nexports.inverse = inverse;\nexports.clone = patch.clone;\n\n// Errors\nexports.InvalidPatchOperationError = require('./lib/InvalidPatchOperationError');\nexports.TestFailedError = require('./lib/TestFailedError');\nexports.PatchNotInvertibleError = require('./lib/PatchNotInvertibleError');\n\nvar isValidObject = patch.isValidObject;\nvar defaultHash = patch.defaultHash;\n\n/**\n * Compute a JSON Patch representing the differences between a and b.\n * @param {object|array|string|number|null} a\n * @param {object|array|string|number|null} b\n * @param {?function|?object} options if a function, see options.hash\n * @param {?function(x:*):String|Number} options.hash used to hash array items\n *  in order to recognize identical objects, defaults to JSON.stringify\n * @param {?function(index:Number, array:Array):object} options.makeContext\n *  used to generate patch context. If not provided, context will not be generated\n * @returns {array} JSON Patch such that patch(diff(a, b), a) ~ b\n */\nfunction diff(a, b, options) {\n\treturn appendChanges(a, b, '', initState(options, [])).patch;\n}\n\n/**\n * Create initial diff state from the provided options\n * @param {?function|?object} options @see diff options above\n * @param {array} patch an empty or existing JSON Patch array into which\n *  the diff should generate new patch operations\n * @returns {object} initialized diff state\n */\nfunction initState(options, patch) {\n\tif(typeof options === 'object') {\n\t\treturn {\n\t\t\tpatch: patch,\n\t\t\thash: orElse(isFunction, options.hash, defaultHash),\n\t\t\tmakeContext: orElse(isFunction, options.makeContext, defaultContext)\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tpatch: patch,\n\t\t\thash: orElse(isFunction, options, defaultHash),\n\t\t\tmakeContext: defaultContext\n\t\t};\n\t}\n}\n\n/**\n * Given two JSON values (object, array, number, string, etc.), find their\n * differences and append them to the diff state\n * @param {object|array|string|number|null} a\n * @param {object|array|string|number|null} b\n * @param {string} path\n * @param {object} state\n * @returns {Object} updated diff state\n */\nfunction appendChanges(a, b, path, state) {\n\tif(Array.isArray(a) && Array.isArray(b)) {\n\t\treturn appendArrayChanges(a, b, path, state);\n\t}\n\n\tif(isValidObject(a) && isValidObject(b)) {\n\t\treturn appendObjectChanges(a, b, path, state);\n\t}\n\n\treturn appendValueChanges(a, b, path, state);\n}\n\n/**\n * Given two objects, find their differences and append them to the diff state\n * @param {object} o1\n * @param {object} o2\n * @param {string} path\n * @param {object} state\n * @returns {Object} updated diff state\n */\nfunction appendObjectChanges(o1, o2, path, state) {\n\tvar keys = Object.keys(o2);\n\tvar patch = state.patch;\n\tvar i, key;\n\n\tfor(i=keys.length-1; i>=0; --i) {\n\t\tkey = keys[i];\n\t\tvar keyPath = path + '/' + encodeSegment(key);\n\t\tif(o1[key] !== void 0) {\n\t\t\tappendChanges(o1[key], o2[key], keyPath, state);\n\t\t} else {\n\t\t\tpatch.push({ op: 'add', path: keyPath, value: o2[key] });\n\t\t}\n\t}\n\n\tkeys = Object.keys(o1);\n\tfor(i=keys.length-1; i>=0; --i) {\n\t\tkey = keys[i];\n\t\tif(o2[key] === void 0) {\n\t\t\tvar p = path + '/' + encodeSegment(key);\n\t\t\tpatch.push({ op: 'test',   path: p, value: o1[key] });\n\t\t\tpatch.push({ op: 'remove', path: p });\n\t\t}\n\t}\n\n\treturn state;\n}\n\n/**\n * Given two arrays, find their differences and append them to the diff state\n * @param {array} a1\n * @param {array} a2\n * @param {string} path\n * @param {object} state\n * @returns {Object} updated diff state\n */\nfunction appendArrayChanges(a1, a2, path, state) {\n\tvar a1hash = array.map(state.hash, a1);\n\tvar a2hash = array.map(state.hash, a2);\n\n\tvar lcsMatrix = lcs.compare(a1hash, a2hash);\n\n\treturn lcsToJsonPatch(a1, a2, path, state, lcsMatrix);\n}\n\n/**\n * Transform an lcsMatrix into JSON Patch operations and append\n * them to state.patch, recursing into array elements as necessary\n * @param {array} a1\n * @param {array} a2\n * @param {string} path\n * @param {object} state\n * @param {object} lcsMatrix\n * @returns {object} new state with JSON Patch operations added based\n *  on the provided lcsMatrix\n */\nfunction lcsToJsonPatch(a1, a2, path, state, lcsMatrix) {\n\tvar offset = 0;\n\treturn lcs.reduce(function(state, op, i, j) {\n\t\tvar last, context;\n\t\tvar patch = state.patch;\n\t\tvar p = path + '/' + (j + offset);\n\n\t\tif (op === lcs.REMOVE) {\n\t\t\t// Coalesce adjacent remove + add into replace\n\t\t\tlast = patch[patch.length-1];\n\t\t\tcontext = state.makeContext(j, a1);\n\n\t\t\tpatch.push({ op: 'test', path: p, value: a1[j], context: context });\n\n\t\t\tif(last !== void 0 && last.op === 'add' && last.path === p) {\n\t\t\t\tlast.op = 'replace';\n\t\t\t\tlast.context = context;\n\t\t\t} else {\n\t\t\t\tpatch.push({ op: 'remove', path: p, context: context });\n\t\t\t}\n\n\t\t\toffset -= 1;\n\n\t\t} else if (op === lcs.ADD) {\n\t\t\t// See https://tools.ietf.org/html/rfc6902#section-4.1\n\t\t\t// May use either index===length *or* '-' to indicate appending to array\n\t\t\tpatch.push({ op: 'add', path: p, value: a2[i],\n\t\t\t\tcontext: state.makeContext(j, a1)\n\t\t\t});\n\n\t\t\toffset += 1;\n\n\t\t} else {\n\t\t\tappendChanges(a1[j], a2[i], p, state);\n\t\t}\n\n\t\treturn state;\n\n\t}, state, lcsMatrix);\n}\n\n/**\n * Given two number|string|null values, if they differ, append to diff state\n * @param {string|number|null} a\n * @param {string|number|null} b\n * @param {string} path\n * @param {object} state\n * @returns {object} updated diff state\n */\nfunction appendValueChanges(a, b, path, state) {\n\tif(a !== b) {\n\t\tstate.patch.push({ op: 'test',    path: path, value: a });\n\t\tstate.patch.push({ op: 'replace', path: path, value: b });\n\t}\n\n\treturn state;\n}\n\n/**\n * @param {function} predicate\n * @param {*} x\n * @param {*} y\n * @returns {*} x if predicate(x) is truthy, otherwise y\n */\nfunction orElse(predicate, x, y) {\n\treturn predicate(x) ? x : y;\n}\n\n/**\n * Default patch context generator\n * @returns {undefined} undefined context\n */\nfunction defaultContext() {\n\treturn void 0;\n}\n\n/**\n * @param {*} x\n * @returns {boolean} true if x is a function, false otherwise\n */\nfunction isFunction(x) {\n\treturn typeof x === 'function';\n}\n","module.exports = InvalidPatchOperationError;\n\nfunction InvalidPatchOperationError(message) {\n\tError.call(this);\n\tthis.name = this.constructor.name;\n\tthis.message = message;\n\tif(typeof Error.captureStackTrace === 'function') {\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\nInvalidPatchOperationError.prototype = Object.create(Error.prototype);\nInvalidPatchOperationError.prototype.constructor = InvalidPatchOperationError;","module.exports = PatchNotInvertibleError;\n\nfunction PatchNotInvertibleError(message) {\n\tError.call(this);\n\tthis.name = this.constructor.name;\n\tthis.message = message;\n\tif(typeof Error.captureStackTrace === 'function') {\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\nPatchNotInvertibleError.prototype = Object.create(Error.prototype);\nPatchNotInvertibleError.prototype.constructor = PatchNotInvertibleError;","module.exports = TestFailedError;\n\nfunction TestFailedError(message) {\n\tError.call(this);\n\tthis.name = this.constructor.name;\n\tthis.message = message;\n\tif(typeof Error.captureStackTrace === 'function') {\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\nTestFailedError.prototype = Object.create(Error.prototype);\nTestFailedError.prototype.constructor = TestFailedError;","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.cons = cons;\nexports.tail = tail;\nexports.map = map;\n\n/**\n * Prepend x to a, without mutating a. Faster than a.unshift(x)\n * @param {*} x\n * @param {Array} a array-like\n * @returns {Array} new Array with x prepended\n */\nfunction cons(x, a) {\n\tvar l = a.length;\n\tvar b = new Array(l+1);\n\tb[0] = x;\n\tfor(var i=0; i<l; ++i) {\n\t\tb[i+1] = a[i];\n\t}\n\n\treturn b;\n}\n\n/**\n * Create a new Array containing all elements in a, except the first.\n *  Faster than a.slice(1)\n * @param {Array} a array-like\n * @returns {Array} new Array, the equivalent of a.slice(1)\n */\nfunction tail(a) {\n\tvar l = a.length-1;\n\tvar b = new Array(l);\n\tfor(var i=0; i<l; ++i) {\n\t\tb[i] = a[i+1];\n\t}\n\n\treturn b;\n}\n\n/**\n * Map any array-like. Faster than Array.prototype.map\n * @param {function} f\n * @param {Array} a array-like\n * @returns {Array} new Array mapped by f\n */\nfunction map(f, a) {\n\tvar b = new Array(a.length);\n\tfor(var i=0; i< a.length; ++i) {\n\t\tb[i] = f(a[i]);\n\t}\n\treturn b;\n}","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * Create a deep copy of x which must be a legal JSON object/array/value\n * @param {object|array|string|number|null} x object/array/value to clone\n * @returns {object|array|string|number|null} clone of x\n */\nmodule.exports = clone;\n\nfunction clone(x) {\n\tif(x == null || typeof x !== 'object') {\n\t\treturn x;\n\t}\n\n\tif(Array.isArray(x)) {\n\t\treturn cloneArray(x);\n\t}\n\n\treturn cloneObject(x);\n}\n\nfunction cloneArray (x) {\n\tvar l = x.length;\n\tvar y = new Array(l);\n\n\tfor (var i = 0; i < l; ++i) {\n\t\ty[i] = clone(x[i]);\n\t}\n\n\treturn y;\n}\n\nfunction cloneObject (x) {\n\tvar keys = Object.keys(x);\n\tvar y = {};\n\n\tfor (var k, i = 0, l = keys.length; i < l; ++i) {\n\t\tk = keys[i];\n\t\ty[k] = clone(x[k]);\n\t}\n\n\treturn y;\n}\n","var jsonPointer = require('./jsonPointer');\n\n/**\n * commute the patch sequence a,b to b,a\n * @param {object} a patch operation\n * @param {object} b patch operation\n */\nmodule.exports = function commutePaths(a, b) {\n\t// TODO: cases for special paths: '' and '/'\n\tvar left = jsonPointer.parse(a.path);\n\tvar right = jsonPointer.parse(b.path);\n\tvar prefix = getCommonPathPrefix(left, right);\n\tvar isArray = isArrayPath(left, right, prefix.length);\n\n\t// Never mutate the originals\n\tvar ac = copyPatch(a);\n\tvar bc = copyPatch(b);\n\n\tif(prefix.length === 0 && !isArray) {\n\t\t// Paths share no common ancestor, simple swap\n\t\treturn [bc, ac];\n\t}\n\n\tif(isArray) {\n\t\treturn commuteArrayPaths(ac, left, bc, right);\n\t} else {\n\t\treturn commuteTreePaths(ac, left, bc, right);\n\t}\n};\n\nfunction commuteTreePaths(a, left, b, right) {\n\tif(a.path === b.path) {\n\t\tthrow new TypeError('cannot commute ' + a.op + ',' + b.op + ' with identical object paths');\n\t}\n\t// FIXME: Implement tree path commutation\n\treturn [b, a];\n}\n\n/**\n * Commute two patches whose common ancestor (which may be the immediate parent)\n * is an array\n * @param a\n * @param left\n * @param b\n * @param right\n * @returns {*}\n */\nfunction commuteArrayPaths(a, left, b, right) {\n\tif(left.length === right.length) {\n\t\treturn commuteArraySiblings(a, left, b, right);\n\t}\n\n\tif (left.length > right.length) {\n\t\t// left is longer, commute by \"moving\" it to the right\n\t\tleft = commuteArrayAncestor(b, right, a, left, -1);\n\t\ta.path = jsonPointer.absolute(jsonPointer.join(left));\n\t} else {\n\t\t// right is longer, commute by \"moving\" it to the left\n\t\tright = commuteArrayAncestor(a, left, b, right, 1);\n\t\tb.path = jsonPointer.absolute(jsonPointer.join(right));\n\t}\n\n\treturn [b, a];\n}\n\nfunction isArrayPath(left, right, index) {\n\treturn jsonPointer.isValidArrayIndex(left[index])\n\t\t&& jsonPointer.isValidArrayIndex(right[index]);\n}\n\n/**\n * Commute two patches referring to items in the same array\n * @param l\n * @param lpath\n * @param r\n * @param rpath\n * @returns {*[]}\n */\nfunction commuteArraySiblings(l, lpath, r, rpath) {\n\n\tvar target = lpath.length-1;\n\tvar lindex = +lpath[target];\n\tvar rindex = +rpath[target];\n\n\tvar commuted;\n\n\tif(lindex < rindex) {\n\t\t// Adjust right path\n\t\tif(l.op === 'add' || l.op === 'copy') {\n\t\t\tcommuted = rpath.slice();\n\t\t\tcommuted[target] = Math.max(0, rindex - 1);\n\t\t\tr.path = jsonPointer.absolute(jsonPointer.join(commuted));\n\t\t} else if(l.op === 'remove') {\n\t\t\tcommuted = rpath.slice();\n\t\t\tcommuted[target] = rindex + 1;\n\t\t\tr.path = jsonPointer.absolute(jsonPointer.join(commuted));\n\t\t}\n\t} else if(r.op === 'add' || r.op === 'copy') {\n\t\t// Adjust left path\n\t\tcommuted = lpath.slice();\n\t\tcommuted[target] = lindex + 1;\n\t\tl.path = jsonPointer.absolute(jsonPointer.join(commuted));\n\t} else if (lindex > rindex && r.op === 'remove') {\n\t\t// Adjust left path only if remove was at a (strictly) lower index\n\t\tcommuted = lpath.slice();\n\t\tcommuted[target] = Math.max(0, lindex - 1);\n\t\tl.path = jsonPointer.absolute(jsonPointer.join(commuted));\n\t}\n\n\treturn [r, l];\n}\n\n/**\n * Commute two patches with a common array ancestor\n * @param l\n * @param lpath\n * @param r\n * @param rpath\n * @param direction\n * @returns {*}\n */\nfunction commuteArrayAncestor(l, lpath, r, rpath, direction) {\n\t// rpath is longer or same length\n\n\tvar target = lpath.length-1;\n\tvar lindex = +lpath[target];\n\tvar rindex = +rpath[target];\n\n\t// Copy rpath, then adjust its array index\n\tvar rc = rpath.slice();\n\n\tif(lindex > rindex) {\n\t\treturn rc;\n\t}\n\n\tif(l.op === 'add' || l.op === 'copy') {\n\t\trc[target] = Math.max(0, rindex - direction);\n\t} else if(l.op === 'remove') {\n\t\trc[target] = Math.max(0, rindex + direction);\n\t}\n\n\treturn rc;\n}\n\nfunction getCommonPathPrefix(p1, p2) {\n\tvar p1l = p1.length;\n\tvar p2l = p2.length;\n\tif(p1l === 0 || p2l === 0 || (p1l < 2 && p2l < 2)) {\n\t\treturn [];\n\t}\n\n\t// If paths are same length, the last segment cannot be part\n\t// of a common prefix.  If not the same length, the prefix cannot\n\t// be longer than the shorter path.\n\tvar l = p1l === p2l\n\t\t? p1l - 1\n\t\t: Math.min(p1l, p2l);\n\n\tvar i = 0;\n\twhile(i < l && p1[i] === p2[i]) {\n\t\t++i\n\t}\n\n\treturn p1.slice(0, i);\n}\n\nfunction copyPatch(p) {\n\tif(p.op === 'remove') {\n\t\treturn { op: p.op, path: p.path };\n\t}\n\n\tif(p.op === 'copy' || p.op === 'move') {\n\t\treturn { op: p.op, path: p.path, from: p.from };\n\t}\n\n\t// test, add, replace\n\treturn { op: p.op, path: p.path, value: p.value };\n}","module.exports = deepEquals;\n\n/**\n * Compare 2 JSON values, or recursively compare 2 JSON objects or arrays\n * @param {object|array|string|number|boolean|null} a\n * @param {object|array|string|number|boolean|null} b\n * @returns {boolean} true iff a and b are recursively equal\n */\nfunction deepEquals(a, b) {\n\tif(a === b) {\n\t\treturn true;\n\t}\n\n\tif(Array.isArray(a) && Array.isArray(b)) {\n\t\treturn compareArrays(a, b);\n\t}\n\n\tif(typeof a === 'object' && typeof b === 'object') {\n\t\treturn compareObjects(a, b);\n\t}\n\n\treturn false;\n}\n\nfunction compareArrays(a, b) {\n\tif(a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor(var i = 0; i<a.length; ++i) {\n\t\tif(!deepEquals(a[i], b[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction compareObjects(a, b) {\n\tif((a === null && b !== null) || (a !== null && b === null)) {\n\t\treturn false;\n\t}\n\n\tvar akeys = Object.keys(a);\n\tvar bkeys = Object.keys(b);\n\n\tif(akeys.length !== bkeys.length) {\n\t\treturn false;\n\t}\n\n\tfor(var i = 0, k; i<akeys.length; ++i) {\n\t\tk = akeys[i];\n\t\tif(!(k in b && deepEquals(a[k], b[k]))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}","var patches = require('./patches');\n\nmodule.exports = function inverse(p) {\n\tvar pr = [];\n\tvar i, skip;\n\tfor(i = p.length-1; i>= 0; i -= skip) {\n\t\tskip = invertOp(pr, p[i], i, p);\n\t}\n\n\treturn pr;\n};\n\nfunction invertOp(patch, c, i, context) {\n\tvar op = patches[c.op];\n\treturn op !== void 0 && typeof op.inverse === 'function'\n\t\t? op.inverse(patch, c, i, context)\n\t\t: 1;\n}\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar patches = require('./patches');\nvar clone = require('./clone');\nvar InvalidPatchOperationError = require('./InvalidPatchOperationError');\n\nexports.apply = patch;\nexports.applyInPlace = patchInPlace;\nexports.clone = clone;\nexports.isValidObject = isValidObject;\nexports.defaultHash = defaultHash;\n\nvar defaultOptions = {};\n\n/**\n * Apply the supplied JSON Patch to x\n * @param {array} changes JSON Patch\n * @param {object|array|string|number} x object/array/value to patch\n * @param {object} options\n * @param {function(index:Number, array:Array, context:object):Number} options.findContext\n *  function used adjust array indexes for smarty/fuzzy patching, for\n *  patches containing context\n * @returns {object|array|string|number} patched version of x. If x is\n *  an array or object, it will be mutated and returned. Otherwise, if\n *  x is a value, the new value will be returned.\n */\nfunction patch(changes, x, options) {\n\treturn patchInPlace(changes, clone(x), options);\n}\n\nfunction patchInPlace(changes, x, options) {\n\tif(!options) {\n\t\toptions = defaultOptions;\n\t}\n\n\t// TODO: Consider throwing if changes is not an array\n\tif(!Array.isArray(changes)) {\n\t\treturn x;\n\t}\n\n\tvar patch, p;\n\tfor(var i=0; i<changes.length; ++i) {\n\t\tp = changes[i];\n\t\tpatch = patches[p.op];\n\n\t\tif(patch === void 0) {\n\t\t\tthrow new InvalidPatchOperationError('invalid op ' + JSON.stringify(p));\n\t\t}\n\n\t\tx = patch.apply(x, p, options);\n\t}\n\n\treturn x;\n}\n\nfunction defaultHash(x) {\n\treturn isValidObject(x) ? JSON.stringify(x) : x;\n}\n\nfunction isValidObject (x) {\n\treturn x !== null && typeof x === 'object';\n}\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nvar _parse = require('./jsonPointerParse');\n\nexports.find = find;\nexports.join = join;\nexports.absolute = absolute;\nexports.parse = parse;\nexports.contains = contains;\nexports.encodeSegment = encodeSegment;\nexports.decodeSegment = decodeSegment;\nexports.parseArrayIndex = parseArrayIndex;\nexports.isValidArrayIndex = isValidArrayIndex;\n\n// http://tools.ietf.org/html/rfc6901#page-2\nvar separator = '/';\nvar separatorRx = /\\//g;\nvar encodedSeparator = '~1';\nvar encodedSeparatorRx = /~1/g;\n\nvar escapeChar = '~';\nvar escapeRx = /~/g;\nvar encodedEscape = '~0';\nvar encodedEscapeRx = /~0/g;\n\n/**\n * Find the parent of the specified path in x and return a descriptor\n * containing the parent and a key.  If the parent does not exist in x,\n * return undefined, instead.\n * @param {object|array} x object or array in which to search\n * @param {string} path JSON Pointer string (encoded)\n * @param {?function(index:Number, array:Array, context:object):Number} findContext\n *  optional function used adjust array indexes for smarty/fuzzy patching, for\n *  patches containing context.  If provided, context MUST also be provided.\n * @param {?{before:Array, after:Array}} context optional patch context for\n *  findContext to use to adjust array indices.  If provided, findContext MUST\n *  also be provided.\n * @returns {{target:object|array|number|string, key:string}|undefined}\n */\nfunction find(x, path, findContext, context) {\n\tif(typeof path !== 'string') {\n\t\treturn;\n\t}\n\n\tif(path === '') {\n\t\t// whole document\n\t\treturn { target: x, key: void 0 };\n\t}\n\n\tif(path === separator) {\n\t\treturn { target: x, key: '' };\n\t}\n\n\tvar parent = x, key;\n\tvar hasContext = context !== void 0;\n\n\t_parse(path, function(segment) {\n\t\t// hm... this seems like it should be if(typeof x === 'undefined')\n\t\tif(x == null) {\n\t\t\t// Signal that we prematurely hit the end of the path hierarchy.\n\t\t\tparent = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tif(Array.isArray(x)) {\n\t\t\tkey = hasContext\n\t\t\t\t? findIndex(findContext, parseArrayIndex(segment), x, context)\n\t\t\t\t: segment === '-' ? segment : parseArrayIndex(segment);\n\t\t} else {\n\t\t\tkey = segment;\n\t\t}\n\n\t\tparent = x;\n\t\tx = x[key];\n\t});\n\n\treturn parent === null\n\t\t? void 0\n\t\t: { target: parent, key: key };\n}\n\nfunction absolute(path) {\n\treturn path[0] === separator ? path : separator + path;\n}\n\nfunction join(segments) {\n\treturn segments.join(separator);\n}\n\nfunction parse(path) {\n\tvar segments = [];\n\t_parse(path, segments.push.bind(segments));\n\treturn segments;\n}\n\nfunction contains(a, b) {\n\treturn b.indexOf(a) === 0 && b[a.length] === separator;\n}\n\n/**\n * Decode a JSON Pointer path segment\n * @see http://tools.ietf.org/html/rfc6901#page-3\n * @param {string} s encoded segment\n * @returns {string} decoded segment\n */\nfunction decodeSegment(s) {\n\t// See: http://tools.ietf.org/html/rfc6901#page-3\n\treturn s.replace(encodedSeparatorRx, separator).replace(encodedEscapeRx, escapeChar);\n}\n\n/**\n * Encode a JSON Pointer path segment\n * @see http://tools.ietf.org/html/rfc6901#page-3\n * @param {string} s decoded segment\n * @returns {string} encoded segment\n */\nfunction encodeSegment(s) {\n\treturn s.replace(escapeRx, encodedEscape).replace(separatorRx, encodedSeparator);\n}\n\nvar arrayIndexRx = /^(0|[1-9]\\d*)$/;\n\n/**\n * Return true if s is a valid JSON Pointer array index\n * @param {String} s\n * @returns {boolean}\n */\nfunction isValidArrayIndex(s) {\n\treturn arrayIndexRx.test(s);\n}\n\n/**\n * Safely parse a string into a number >= 0. Does not check for decimal numbers\n * @param {string} s numeric string\n * @returns {number} number >= 0\n */\nfunction parseArrayIndex (s) {\n\tif(isValidArrayIndex(s)) {\n\t\treturn +s;\n\t}\n\n\tthrow new SyntaxError('invalid array index ' + s);\n}\n\nfunction findIndex (findContext, start, array, context) {\n\tvar index = start;\n\n\tif(index < 0) {\n\t\tthrow new Error('array index out of bounds ' + index);\n\t}\n\n\tif(context !== void 0 && typeof findContext === 'function') {\n\t\tindex = findContext(start, array, context);\n\t\tif(index < 0) {\n\t\t\tthrow new Error('could not find patch context ' + context);\n\t\t}\n\t}\n\n\treturn index;\n}","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nmodule.exports = jsonPointerParse;\n\nvar parseRx = /\\/|~1|~0/g;\nvar separator = '/';\nvar escapeChar = '~';\nvar encodedSeparator = '~1';\n\n/**\n * Parse through an encoded JSON Pointer string, decoding each path segment\n * and passing it to an onSegment callback function.\n * @see https://tools.ietf.org/html/rfc6901#section-4\n * @param {string} path encoded JSON Pointer string\n * @param {{function(segment:string):boolean}} onSegment callback function\n * @returns {string} original path\n */\nfunction jsonPointerParse(path, onSegment) {\n\tvar pos, accum, matches, match;\n\n\tpos = path.charAt(0) === separator ? 1 : 0;\n\taccum = '';\n\tparseRx.lastIndex = pos;\n\n\twhile(matches = parseRx.exec(path)) {\n\n\t\tmatch = matches[0];\n\t\taccum += path.slice(pos, parseRx.lastIndex - match.length);\n\t\tpos = parseRx.lastIndex;\n\n\t\tif(match === separator) {\n\t\t\tif (onSegment(accum) === false) return path;\n\t\t\taccum = '';\n\t\t} else {\n\t\t\taccum += match === encodedSeparator ? separator : escapeChar;\n\t\t}\n\t}\n\n\taccum += path.slice(pos);\n\tonSegment(accum);\n\n\treturn path;\n}\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexports.compare = compare;\nexports.reduce = reduce;\n\nvar REMOVE, RIGHT, ADD, DOWN, SKIP;\n\nexports.REMOVE = REMOVE = RIGHT = -1;\nexports.ADD    = ADD    = DOWN  =  1;\nexports.EQUAL  = SKIP   = 0;\n\n/**\n * Create an lcs comparison matrix describing the differences\n * between two array-like sequences\n * @param {array} a array-like\n * @param {array} b array-like\n * @returns {object} lcs descriptor, suitable for passing to reduce()\n */\nfunction compare(a, b) {\n\tvar cols = a.length;\n\tvar rows = b.length;\n\n\tvar prefix = findPrefix(a, b);\n\tvar suffix = prefix < cols && prefix < rows\n\t\t? findSuffix(a, b, prefix)\n\t\t: 0;\n\n\tvar remove = suffix + prefix - 1;\n\tcols -= remove;\n\trows -= remove;\n\tvar matrix = createMatrix(cols, rows);\n\n\tfor (var j = cols - 1; j >= 0; --j) {\n\t\tfor (var i = rows - 1; i >= 0; --i) {\n\t\t\tmatrix[i][j] = backtrack(matrix, a, b, prefix, j, i);\n\t\t}\n\t}\n\n\treturn {\n\t\tprefix: prefix,\n\t\tmatrix: matrix,\n\t\tsuffix: suffix\n\t};\n}\n\n/**\n * Reduce a set of lcs changes previously created using compare\n * @param {function(result:*, type:number, i:number, j:number)} f\n *  reducer function, where:\n *  - result is the current reduce value,\n *  - type is the type of change: ADD, REMOVE, or SKIP\n *  - i is the index of the change location in b\n *  - j is the index of the change location in a\n * @param {*} r initial value\n * @param {object} lcs results returned by compare()\n * @returns {*} the final reduced value\n */\nfunction reduce(f, r, lcs) {\n\tvar i, j, k, op;\n\n\tvar m = lcs.matrix;\n\n\t// Reduce shared prefix\n\tvar l = lcs.prefix;\n\tfor(i = 0;i < l; ++i) {\n\t\tr = f(r, SKIP, i, i);\n\t}\n\n\t// Reduce longest change span\n\tk = i;\n\tl = m.length;\n\ti = 0;\n\tj = 0;\n\twhile(i < l) {\n\t\top = m[i][j].type;\n\t\tr = f(r, op, i+k, j+k);\n\n\t\tswitch(op) {\n\t\t\tcase SKIP:  ++i; ++j; break;\n\t\t\tcase RIGHT: ++j; break;\n\t\t\tcase DOWN:  ++i; break;\n\t\t}\n\t}\n\n\t// Reduce shared suffix\n\ti += k;\n\tj += k;\n\tl = lcs.suffix;\n\tfor(k = 0;k < l; ++k) {\n\t\tr = f(r, SKIP, i+k, j+k);\n\t}\n\n\treturn r;\n}\n\nfunction findPrefix(a, b) {\n\tvar i = 0;\n\tvar l = Math.min(a.length, b.length);\n\twhile(i < l && a[i] === b[i]) {\n\t\t++i;\n\t}\n\treturn i;\n}\n\nfunction findSuffix(a, b) {\n\tvar al = a.length - 1;\n\tvar bl = b.length - 1;\n\tvar l = Math.min(al, bl);\n\tvar i = 0;\n\twhile(i < l && a[al-i] === b[bl-i]) {\n\t\t++i;\n\t}\n\treturn i;\n}\n\nfunction backtrack(matrix, a, b, start, j, i) {\n\tif (a[j+start] === b[i+start]) {\n\t\treturn { value: matrix[i + 1][j + 1].value, type: SKIP };\n\t}\n\tif (matrix[i][j + 1].value < matrix[i + 1][j].value) {\n\t\treturn { value: matrix[i][j + 1].value + 1, type: RIGHT };\n\t}\n\n\treturn { value: matrix[i + 1][j].value + 1, type: DOWN };\n}\n\nfunction createMatrix (cols, rows) {\n\tvar m = [], i, j, lastrow;\n\n\t// Fill the last row\n\tlastrow = m[rows] = [];\n\tfor (j = 0; j<cols; ++j) {\n\t\tlastrow[j] = { value: cols - j, type: RIGHT };\n\t}\n\n\t// Fill the last col\n\tfor (i = 0; i<rows; ++i) {\n\t\tm[i] = [];\n\t\tm[i][cols] = { value: rows - i, type: DOWN };\n\t}\n\n\t// Fill the last cell\n\tm[rows][cols] = { value: 0, type: SKIP };\n\n\treturn m;\n}\n","var jsonPointer = require('./jsonPointer');\nvar clone = require('./clone');\nvar deepEquals = require('./deepEquals');\nvar commutePaths = require('./commutePaths');\n\nvar array = require('./array');\n\nvar TestFailedError = require('./TestFailedError');\nvar InvalidPatchOperationError = require('./InvalidPatchOperationError');\nvar PatchNotInvertibleError = require('./PatchNotInvertibleError');\n\nvar find = jsonPointer.find;\nvar parseArrayIndex = jsonPointer.parseArrayIndex;\n\nexports.test = {\n\tapply: applyTest,\n\tinverse: invertTest,\n\tcommute: commuteTest\n};\n\nexports.add = {\n\tapply: applyAdd,\n\tinverse: invertAdd,\n\tcommute: commuteAddOrCopy\n};\n\nexports.remove = {\n\tapply: applyRemove,\n\tinverse: invertRemove,\n\tcommute: commuteRemove\n};\n\nexports.replace = {\n\tapply: applyReplace,\n\tinverse: invertReplace,\n\tcommute: commuteReplace\n};\n\nexports.move = {\n\tapply: applyMove,\n\tinverse: invertMove,\n\tcommute: commuteMove\n};\n\nexports.copy = {\n\tapply: applyCopy,\n\tinverse: notInvertible,\n\tcommute: commuteAddOrCopy\n};\n\n/**\n * Apply a test operation to x\n * @param {object|array} x\n * @param {object} test test operation\n * @throws {TestFailedError} if the test operation fails\n */\n\nfunction applyTest(x, test, options) {\n\tvar pointer = find(x, test.path, options.findContext, test.context);\n\tvar target = pointer.target;\n\tvar index, value;\n\n\tif(Array.isArray(target)) {\n\t\tindex = parseArrayIndex(pointer.key);\n\t\t//index = findIndex(options.findContext, index, target, test.context);\n\t\tvalue = target[index];\n\t} else {\n\t\tvalue = pointer.key === void 0 ? pointer.target : pointer.target[pointer.key];\n\t}\n\n\tif(!deepEquals(value, test.value)) {\n\t\tthrow new TestFailedError('test failed ' + JSON.stringify(test));\n\t}\n\n\treturn x;\n}\n\n/**\n * Invert the provided test and add it to the inverted patch sequence\n * @param pr\n * @param test\n * @returns {number}\n */\nfunction invertTest(pr, test) {\n\tpr.push(test);\n\treturn 1;\n}\n\nfunction commuteTest(test, b) {\n\tif(test.path === b.path && b.op === 'remove') {\n\t\tthrow new TypeError('Can\\'t commute test,remove -> remove,test for same path');\n\t}\n\n\tif(b.op === 'test' || b.op === 'replace') {\n\t\treturn [b, test];\n\t}\n\n\treturn commutePaths(test, b);\n}\n\n/**\n * Apply an add operation to x\n * @param {object|array} x\n * @param {object} change add operation\n */\nfunction applyAdd(x, change, options) {\n\tvar pointer = find(x, change.path, options.findContext, change.context);\n\n\tif(notFound(pointer)) {\n\t\tthrow new InvalidPatchOperationError('path does not exist ' + change.path);\n\t}\n\n\tvar val = clone(change.value);\n\n\t// If pointer refers to whole document, replace whole document\n\tif(pointer.key === void 0) {\n\t\treturn val;\n\t}\n\n\t_add(pointer, val);\n\treturn x;\n}\n\nfunction _add(pointer, value) {\n\tvar target = pointer.target;\n\n\tif(Array.isArray(target)) {\n\t\t// '-' indicates 'append' to array\n\t\tif(pointer.key === '-') {\n\t\t\ttarget.push(value);\n\t\t} else {\n\t\t\ttarget.splice(pointer.key, 0, value);\n\t\t}\n\t} else if(isValidObject(target)) {\n\t\ttarget[pointer.key] = value;\n\t} else {\n\t\tthrow new InvalidPatchOperationError('target of add must be an object or array ' + pointer.key);\n\t}\n}\n\nfunction invertAdd(pr, add) {\n\tvar context = add.context;\n\tif(context !== void 0) {\n\t\tcontext = {\n\t\t\tbefore: context.before,\n\t\t\tafter: array.cons(add.value, context.after)\n\t\t}\n\t}\n\tpr.push({ op: 'test', path: add.path, value: add.value, context: context });\n\tpr.push({ op: 'remove', path: add.path, context: context });\n\treturn 1;\n}\n\nfunction commuteAddOrCopy(add, b) {\n\tif(add.path === b.path && b.op === 'remove') {\n\t\tthrow new TypeError('Can\\'t commute add,remove -> remove,add for same path');\n\t}\n\n\treturn commutePaths(add, b);\n}\n\n/**\n * Apply a replace operation to x\n * @param {object|array} x\n * @param {object} change replace operation\n */\nfunction applyReplace(x, change, options) {\n\tvar pointer = find(x, change.path, options.findContext, change.context);\n\n\tif(notFound(pointer) || missingValue(pointer)) {\n\t\tthrow new InvalidPatchOperationError('path does not exist ' + change.path);\n\t}\n\n\tvar value = clone(change.value);\n\n\t// If pointer refers to whole document, replace whole document\n\tif(pointer.key === void 0) {\n\t\treturn value;\n\t}\n\n\tvar target = pointer.target;\n\n\tif(Array.isArray(target)) {\n\t\ttarget[parseArrayIndex(pointer.key)] = value;\n\t} else {\n\t\ttarget[pointer.key] = value;\n\t}\n\n\treturn x;\n}\n\nfunction invertReplace(pr, c, i, patch) {\n\tvar prev = patch[i-1];\n\tif(prev === void 0 || prev.op !== 'test' || prev.path !== c.path) {\n\t\tthrow new PatchNotInvertibleError('cannot invert replace w/o test');\n\t}\n\n\tvar context = prev.context;\n\tif(context !== void 0) {\n\t\tcontext = {\n\t\t\tbefore: context.before,\n\t\t\tafter: array.cons(prev.value, array.tail(context.after))\n\t\t}\n\t}\n\n\tpr.push({ op: 'test', path: prev.path, value: c.value });\n\tpr.push({ op: 'replace', path: prev.path, value: prev.value });\n\treturn 2;\n}\n\nfunction commuteReplace(replace, b) {\n\tif(replace.path === b.path && b.op === 'remove') {\n\t\tthrow new TypeError('Can\\'t commute replace,remove -> remove,replace for same path');\n\t}\n\n\tif(b.op === 'test' || b.op === 'replace') {\n\t\treturn [b, replace];\n\t}\n\n\treturn commutePaths(replace, b);\n}\n\n/**\n * Apply a remove operation to x\n * @param {object|array} x\n * @param {object} change remove operation\n */\nfunction applyRemove(x, change, options) {\n\tvar pointer = find(x, change.path, options.findContext, change.context);\n\n\t// key must exist for remove\n\tif(notFound(pointer) || pointer.target[pointer.key] === void 0) {\n\t\tthrow new InvalidPatchOperationError('path does not exist ' + change.path);\n\t}\n\n\t_remove(pointer);\n\treturn x;\n}\n\nfunction _remove (pointer) {\n\tvar target = pointer.target;\n\n\tvar removed;\n\tif (Array.isArray(target)) {\n\t\tremoved = target.splice(parseArrayIndex(pointer.key), 1);\n\t\treturn removed[0];\n\n\t} else if (isValidObject(target)) {\n\t\tremoved = target[pointer.key];\n\t\tdelete target[pointer.key];\n\t\treturn removed;\n\n\t} else {\n\t\tthrow new InvalidPatchOperationError('target of remove must be an object or array');\n\t}\n}\n\nfunction invertRemove(pr, c, i, patch) {\n\tvar prev = patch[i-1];\n\tif(prev === void 0 || prev.op !== 'test' || prev.path !== c.path) {\n\t\tthrow new PatchNotInvertibleError('cannot invert remove w/o test');\n\t}\n\n\tvar context = prev.context;\n\tif(context !== void 0) {\n\t\tcontext = {\n\t\t\tbefore: context.before,\n\t\t\tafter: array.tail(context.after)\n\t\t}\n\t}\n\n\tpr.push({ op: 'add', path: prev.path, value: prev.value, context: context });\n\treturn 2;\n}\n\nfunction commuteRemove(remove, b) {\n\tif(remove.path === b.path && b.op === 'remove') {\n\t\treturn [b, remove];\n\t}\n\n\treturn commutePaths(remove, b);\n}\n\n/**\n * Apply a move operation to x\n * @param {object|array} x\n * @param {object} change move operation\n */\nfunction applyMove(x, change, options) {\n\tif(jsonPointer.contains(change.path, change.from)) {\n\t\tthrow new InvalidPatchOperationError('move.from cannot be ancestor of move.path');\n\t}\n\n\tvar pto = find(x, change.path, options.findContext, change.context);\n\tvar pfrom = find(x, change.from, options.findContext, change.fromContext);\n\n\t_add(pto, _remove(pfrom));\n\treturn x;\n}\n\nfunction invertMove(pr, c) {\n\tpr.push({ op: 'move',\n\t\tpath: c.from, context: c.fromContext,\n\t\tfrom: c.path, fromContext: c.context });\n\treturn 1;\n}\n\nfunction commuteMove(move, b) {\n\tif(move.path === b.path && b.op === 'remove') {\n\t\tthrow new TypeError('Can\\'t commute move,remove -> move,replace for same path');\n\t}\n\n\treturn commutePaths(move, b);\n}\n\n/**\n * Apply a copy operation to x\n * @param {object|array} x\n * @param {object} change copy operation\n */\nfunction applyCopy(x, change, options) {\n\tvar pto = find(x, change.path, options.findContext, change.context);\n\tvar pfrom = find(x, change.from, options.findContext, change.fromContext);\n\n\tif(notFound(pfrom) || missingValue(pfrom)) {\n\t\tthrow new InvalidPatchOperationError('copy.from must exist');\n\t}\n\n\tvar target = pfrom.target;\n\tvar value;\n\n\tif(Array.isArray(target)) {\n\t\tvalue = target[parseArrayIndex(pfrom.key)];\n\t} else {\n\t\tvalue = target[pfrom.key];\n\t}\n\n\t_add(pto, clone(value));\n\treturn x;\n}\n\n// NOTE: Copy is not invertible\n// See https://github.com/cujojs/jiff/issues/9\n// This needs more thought. We may have to extend/amend JSON Patch.\n// At first glance, this seems like it should just be a remove.\n// However, that's not correct.  It violates the involution:\n// invert(invert(p)) ~= p.  For example:\n// invert(copy) -> remove\n// invert(remove) -> add\n// thus: invert(invert(copy)) -> add (DOH! this should be copy!)\n\nfunction notInvertible(_, c) {\n\tthrow new PatchNotInvertibleError('cannot invert ' + c.op);\n}\n\nfunction notFound (pointer) {\n\treturn pointer === void 0 || (pointer.target == null && pointer.key !== void 0);\n}\n\nfunction missingValue(pointer) {\n\treturn pointer.key !== void 0 && pointer.target[pointer.key] === void 0;\n}\n\n/**\n * Return true if x is a non-null object\n * @param {*} x\n * @returns {boolean}\n */\nfunction isValidObject (x) {\n\treturn x !== null && typeof x === 'object';\n}\n"],"sourceRoot":"/source/"}